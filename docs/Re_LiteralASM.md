# LiteralASM / FastJNI
勉强能用，问题很多  

缺点如下：  
- 不支持ZGC  
- 不支持ShenandoahGC  
- 仅支持x86_64体系的Windows上的JDK  
- 长时间运行的FastJNI函数可能阻塞整个JVM  
- 参数中不存在JNIEnv
- 不支持部分JVM和OS版本 （真是绝了）
- 必须是静态方法
- 性能追踪工具无法追踪这种方法调用

优点如下：
- 参数可以直接传入对象，在函数执行期间，它是不变的指针，没有复制的开销，可以直接修改  
目前无论是否传入对象都会阻塞GC  
字段偏移可以在其它正常JNI函数中获取

- 没有任何调用开销 和Java原生方法相同
- 除了FastJNI，你还可以插入汇编代码，但是应该没人会这么做