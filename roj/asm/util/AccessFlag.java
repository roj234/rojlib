package roj.asm.util;

import roj.util.Helpers;

import java.io.IOException;

/**
 * @author Roj234
 * @since 2021/5/11 0:59
 */
public class AccessFlag {
	public static final char
		PUBLIC = 0x0001,
		PRIVATE = 0x0002,
		PROTECTED = 0x0004,
		STATIC = 0x0008,
		FINAL = 0x0010,
		SUPER = 0x0020, SYNCHRONIZED = 0x0020,
		VOLATILE = 0x0040, BRIDGE = 0x0040,
		TRANSIENT = 0x0080, VARARGS = 0x0080,
		NATIVE = 0x0100,
		INTERFACE = 0x0200,
		ABSTRACT = 0x0400,
		STRICTFP = 0x0800,
		SYNTHETIC = 0x1000,
		ANNOTATION = 0x2000,
		ENUM = 0x4000,
		MODULE = 0x8000;

	public static final char
		M_OPEN = 0x0020,
		M_MANDATED = 0x8000,
		M_TRANSITIVE = 0x0020,
		M_STATIC_PHASE = 0x0040;

	/**
	 * ACC_PUBLIC	    0x0001	Declared public; may be accessed from outside its package.
	 * ACC_PRIVATE	    0x0002	Declared private; accessible only within the defining class.
	 * ACC_PROTECTED	0x0004	Declared protected; may be accessed within subclasses.
	 * ACC_STATIC	    0x0008	Declared static.
	 * ACC_FINAL	    0x0010	Declared final; must not be overridden (§5.4.5).
	 * ACC_SYNCHRONIZED	0x0020	Declared synchronized; invocation is wrapped by a monitor use.
	 * ACC_BRIDGE	    0x0040	A bridge method, generated by the compiler.
	 * ACC_VARARGS	    0x0080	Declared with variable number of arguments.
	 * ACC_NATIVE	    0x0100	Declared native; implemented in a language other than Java.
	 * ACC_ABSTRACT	    0x0400	Declared abstract; no implementation is provided.
	 * ACC_STRICT	    0x0800	Declared strictfp; floating-point mode is FP-strict.
	 * ACC_SYNTHETIC	0x1000	Declared synthetic; not present in the source code.
	 */
	public static final String[] METHOD_ACC = new String[]{
		"public", "private", "protected", "static", "final", "synchronized", "bridge", "varargs", "native", null, "abstract", "strictfp", "synthetic"
	};

	/**
	 * ACC_PUBLIC	    0x0001	Declared public; may be accessed from outside its package.
	 * ACC_PRIVATE	    0x0002	Declared private; usable only within the defining class.
	 * ACC_PROTECTED	0x0004	Declared protected; may be accessed within subclasses.
	 * ACC_STATIC	    0x0008	Declared static.
	 * ACC_FINAL	    0x0010	Declared final; never directly assigned to after object construction (JLS §17.5).
	 * ACC_VOLATILE	    0x0040	Declared volatile; cannot be cached.
	 * ACC_TRANSIENT	0x0080	Declared transient; not written or read by a persistent object manager.
	 * ACC_SYNTHETIC	0x1000	Declared synthetic; not present in the source code.
	 * ACC_ENUM	        0x4000	Declared as an element of an enum.
	 */
	public static final String[] FIELD_ACC = new String[]{
		"public", "private", "protected", "static", "final", null, "volatile", "transient", null, null, null, null, "synthetic", null, "enum"
	};

	/**
	 * ACC_PUBLIC	    0x0001	Declared public; may be accessed from outside its package.
	 * ACC_FINAL	    0x0010	Declared final; no subclasses allowed.
	 * ACC_SUPER	    0x0020	Treat superclass methods specially when invoked by the invokespecial instruction.
	 * ACC_INTERFACE	0x0200	Is an interface, not a class.
	 * ACC_ABSTRACT	    0x0400	Declared abstract; must not be instantiated.
	 * ACC_SYNTHETIC	0x1000	Declared synthetic; not present in the source code.
	 * ACC_ANNOTATION	0x2000	Declared as an annotation type.
	 * ACC_ENUM	        0x4000	Declared as an enum type.
	 * ACC_MODULE       0x8000  Declared as an module type;
	 */
	public static final String[] CLASS_ACC = new String[]{
		"public", null, null, null, "final", "class", null, null, null, "interface", "abstract", null, "synthetic", "annotation", "enum", "module"
	};

	/**
	 * ACC_PUBLIC	    0x0001	Marked or implicitly public in source.
	 * ACC_PRIVATE	    0x0002	Marked private in source.
	 * ACC_PROTECTED	0x0004	Marked protected in source.
	 * ACC_STATIC	    0x0008	Marked or implicitly static in source.
	 * ACC_FINAL	    0x0010	Marked final in source.
	 * ACC_INTERFACE	0x0200	Was an interface in source.
	 * ACC_ABSTRACT	    0x0400	Marked or implicitly abstract in source.
	 * ACC_SYNTHETIC	0x1000	Declared synthetic; not present in the source code.
	 * ACC_ANNOTATION	0x2000	Declared as an annotation type.
	 * ACC_ENUM	        0x4000	Declared as an enum type.
	 */
	public static final String[] INNER_CLASS_ACC = new String[]{
		"public", "private", "protected", "static", "final", null, null, null, null, "interface", "abstract", null, "synthetic", "annotation", "enum"
	};

	/**
	 * ACC_OPEN         0x0020  Indicates that this module is open.
	 * ACC_TRANSITIVE   0x0020	Indicates that any module which depends on the current module, implicitly declares a dependence on the module indicated by this entry. ('转移性')
	 * ACC_STATIC_PHASE	0x0040	Mandatory in the static phase, 'compile', but is optional in the dynamic phase, 'run'.
	 * ACC_SYNTHETIC	0x1000	Declared synthetic; not present in the source code.
	 * ACC_MANDATED     0x8000  Indicates that this dependence was implicitly declared in the source of the module declaration.
	 */
	public static final String[] MODULE_ACC = new String[]{
		null, null, null, null, null, "open / transitive", "static_phase", null, null, null, null, null, "synthetic", null, null, "mandated"
	};

	public static final int TS_CLASS   = 0;
	public static final int TS_PARAM   = 1;
	public static final int TS_METHOD  = 2;
	public static final int TS_FIELD   = 3;
	public static final int TS_INNER   = 4;
	public static final int TS_MODULE  = 5;

	public static String toString(int flag, int type) {
		return toString(flag, type, new StringBuilder()).toString();
	}

	public static <T extends Appendable> T toString(int flag, int type, T sb) {
		String[] names;
		switch (type) {
			case TS_CLASS: names = CLASS_ACC; break;
			case TS_FIELD:
			case TS_PARAM: names = FIELD_ACC; break;
			case TS_INNER: names = INNER_CLASS_ACC; break;
			case TS_METHOD: names = METHOD_ACC; break;
			case TS_MODULE: names = MODULE_ACC; break;
			default: return sb;
		}

		try {
			for (int i = 0; i < names.length; i++) {
				if ((flag & (1 << i)) != 0) {
					String s = names[i];
					if (s != null) sb.append(s).append(' ');
				}
			}
		} catch (IOException e) {
			Helpers.athrow(e);
		}
		return sb;
	}
}
